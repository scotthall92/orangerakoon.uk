<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Unawakening: Return to the Island</title>
    <link rel="stylesheet" type="text/css" href="unawakening.css" title="Unawakening">

    <!--
      ____                             _____       _
     / __ \                           |  __ \     | |
    | |  | |_ __ __ _ _ __   __ _  ___| |__) |__ _| | _____   ___  _ __
    | |  | | '__/ _` | '_ \ / _` |/ _ \  _  // _` | |/ / _ \ / _ \| '_ \
    | |__| | | | (_| | | | | (_| |  __/ | \ \ (_| |   < (_) | (_) | | | |
     \____/|_|  \__,_|_| |_|\__, |\___|_|  \_\__,_|_|\_\___/ \___/|_| |_|.uk
    =========================__/ |==========================================
                            |___/  Author: Scott Hall   github: scotthall92
    -->

</head>
<body onload="init()">

<div>
<button onclick="resizeCanvas(1)">+</button>
<button onclick="resizeCanvas(-1)">-</button>
</div>

<p><canvas id="screenCanvas" width="192" height="144">Unsupported by browser</canvas></p>
<img id="tileset1" src="tileset1.png" width=0 height=0>
<img id="tileset2" src="tileset2.png" width=0 height=0>
<img id="charset" src="charset.png" width=0 height=0>
<img id="player" src="player.png" width=0 height=0>
<img id="npcset" src="npcset.png" width=0 height=0>

<script type="text/javascript">

var c = document.getElementById("screenCanvas");
var ctx = c.getContext("2d");
var scale = 2;

var fps = 60;
var mspf = 1000 / fps; // ms per frame

var frameCount3 = 1;

var tilesets = [document.getElementById("tileset1"), document.getElementById("tileset2")];
var tsize = 12;

var npcset = document.getElementById("npcset");

var charset = document.getElementById("charset");
var csize = 6;

var screenTileWidth = 8;
var screenTileHeight = 6;

var mapXCoord = 0;
var mapYCoord = 0;
var locale = [];
var localNPCs = [];
var localNPCDirections = [];    // 0: -x, 1: +x, 2: -y, 3: +y

var player = document.getElementById("player");
var psize = 12;

var playerPosX = 0;
var playerPosY = 0;
var playerDirection = [0,0,1,0];  // +x,-x,+y,-y
var playerMoving = false;
var playerPushing = false;
var playerDown = true;
var playerAnimationFrame = 1;
var playerAnimationBufferMax = 12;
var playerAnimationBuffer = 0;

var wasMovingX = 0;
var wasMovingY = 0;

var npcAnimationFrame = 1;
var npcAnimationBufferMax = 12;
var npcAnimationBuffer = 0;

var overscan = 2;
var minPosX = -overscan;
var minPosY = -overscan;
var maxPosX = (tsize * screenTileWidth) - psize + overscan;
var maxPosY = (tsize * screenTileHeight) - psize + overscan;

var inputDelayBuffer = 0;

var reverseInputDelay = 3;

var transitionBufferMax = 6;
var transitionXBuffer = 0;
var transitionYBuffer = 0;
var transitionInputDelay = 6;

var portalBufferMax = 6;
var portalBuffer = 0;
var kennelBuffer = 0;
var portalInputDelay = 12;

var dialogueBuffer = [];
var dialogueInputDelay = 10;
var dialogueFirstLine = "";
var dialogueSecondLine = "";

var keyMap = {};

function keydown(event) {
    if (!event.repeat) {
        keyMap[event.key] = true;
    }
}

function keyup(event) {
    keyMap[event.key] = false;
}

function blur(event) {
    keyMap = {};
}

document.onkeydown = keydown;
document.onkeyup = keyup;
document.body.onblur = blur;

var passableTiles = [
    ["OOB","22","03","23","04","14","24","34","25","35","45","55","46","07","17","27","67","77","08","18","28","68","78","09","19","29","69","79","21","43","53"],
    ["OOB","31","41","04","14","24","34","05","15","25", "35","13"],
];

var portalTiles = [
    ["21","43","53"],
    ["13"],
];

var signpostTiles = [["44"], []];
var heavyTiles = [["60"], ["43"]];
var drawerTiles = [[], ["40"]];
var grassTiles = [["23"], []];

var outsideMap = {
    "00": "885967676723380158776767672339985867001013670338586701111303233858670377672323388957676723233799",
    "10": "110111011101110170808090626262007136369133533301713636849023238771363636911818037282828292181818",
    "20": "110111011101110110133141414151031113324242425218809033433343330318911334343434341884808080762275",
    "30": "110111011101110118626262181803180363536318181818180467040318181834340318709703007622758094181801",
    "40": "110111011101021218031818181301111818030010031300181823011123130110180323230300101118180303180111",
    "01": "495967676703390090001067672323019101021003672300849001021067001286910012116701023691010210670012",
    "11": "100010001018181811011101111803181000201018181818110121111800101810031818180111180210181818181818",
    "21": "188681818181228114031465240324182403246614032418140324242403241824240303031424342424242424241418",
    "31": "812281819618180034341313180318013431415113343434343040501334180034334333133403013434343434341800",
    "41": "101818182323001011184418232301113434343434136034101818181813601802102323231300101202102323001211",
    "02": "369100121167010236910111443423013691879018343434369118848080970336910354615434343691181867183400",
    "12": "121123232323181811314151231818183432425262180318343343335354232334343464232323181003343434343434",
    "22": "181818181818181818545454545454180354626262001023185433433301112318545434545454183434343418181818",
    "32": "181818181818180118133141511370801813304050137136031333533313713618181318131872821803181818232300",
    "42": "110111232301021090232323232301119123232323560010912323562356011192230010235600101000121123230111",
    "03": "369118183434340183921818340318009118877622759701911844033418180091181834341818018480762275808080",
    "13": "110318031818180310626231615123181163633242522318102323335333231811181818181803188080808080808080",
    "23": "181818181818181803708022902323231871464691232318237282829223181803182323231818038080808080808080",
    "33": "232323232323230123131313131323002313131313132301231313131313230023232323232323018080808080808090",
    "43": "110111442323001010440717274401111107790369172700100978441844280111130919191929007080902323232301",
    "04": "858181228181818191252525252525259125707622759725912571353555353591257135353535357380742626262626",
    "14": "818181818181818125626262051525252533533306162583352525253535557335353535453535352626262626262683",
    "24": "818181818181818125252525252525258293353535353583807435354535559135353545353535738293262626262626",
    "34": "818181818181819135353555353535919305153535051591710616353506169174353535353535842626262626262686",
    "44": "718191232303180071369162626223017136913353332300713684902323030194368684808080809636368681818181",
};

var insideMap = {
    "00": "003030303030302001313131313131210152045204045221010404040404042101520404040452210212120313231222",
    "10": "001010101010101001001011102024040101430404212404010212341222240401434324242424040212120313231212",
    "20": "101040104040402004044104414141210452440444444421045345044545452104040404040404211212031323121222",
    "01": "353535353535353535353535353535353500405010203535350141510421353535010404042135353502031323223535",
    "11": "001010401010102001434341040404210143430404040421014343043242042101434324242404210212120313231222",
    "21": "001040101010102001434143434344210143432424434521014333242454432101430404040443210212031323121222",
    "02": "001010104010102001440453414343210145043242434321010404045304432101525304040443210212031323121222",
    "12": "102035353535353543213535353535354321001010102035432101051505213543210105050521351222020313232235",
    "22": "001010101040102001442444244133210145244524045321012424242432422101434304040453210212120313231222",
    "03": "001040404040102001044141414104210132420444445221015304044545042101522424240443210212031323121222",
    "13": "001010104040102001254425414143210125452504044321012525250404042101333333043333210212120313231222",
    "23": "001040101010102001144114141455210114440433523321010445140404142101141404044343210212031323121222",
};

var maps = [outsideMap, insideMap];

var mapIndex = 0;
var map = maps[mapIndex];
var tileset = tilesets[mapIndex];

var characters = " ABCDEFGHIJKLMNOPQRSTUVWXYZ#abcdefghijklmnopqrstuvwxyz0123456789.,!?-':*^>_<";

var dialoguesDefault = {
    "init": ["", "move:", ":use WASD to", "interact:", ":press J to"],
    "signpost": ["", "this angle!", "sign from", "read the", "You can't"],
    "heavy": ["", "this!", "can't lift", "definitely", "Yep! You", "", ": : :", "", "heavy!", "looks pretty", "Oof! This"],
    "drawer": ["", "drawers?", "people's", "in other", "always look", "Do you"],
};
// Map Index, Map X Coord, Map Y Coord, Tile x, Tile y
var dialoguesStatic = {
    "00415": ["", "place:", "was a secret", "This cliff"],
    "00323": ["", "Library", "pond - Bema", "the fishing", "Find us by", "We've moved!"],
    "01353": ["", "are closed:", "The curtains", ":Huh?"],
    "02132": ["", "move.", "heavy to", "It's too", ": :", ":"],
    "00241": ["", "    Village", " >  Bema", "    Woods", " ^  Endless"],
    "00244": ["", "pretty deep!", "It looks", "well:", "Well, well,"],
    "04121": ["", "roads!", "maintained", "our well-", "ourselves on", "- We pride", "Bema Village", "Welcome to"],
    "04330": ["", "", "Start _"],
    "04311": ["", "", "Finish!"],
    "04351": ["", "", "      <"],
    "04333": ["", "", "      >"],
    "04353": ["", "", "      ^"],
    "10133": ["", "playing!", "Thanks for", "", "OrangeRKN", "Last post by", "", "------------", "grcade.co.uk", "", ":: *beep*"],
    "10010": ["", "put it back.", "boring. I'll", ":eh, sounds", "'Credits'"],
    "10020": ["", "quite funny!", "These are", "book. Heh!", "It's a joke"],
    "10030": ["", "expecting?", "were you", "books: what", "stacked with", "The shelf is"],
    "10040": ["", "helpful:", "wasn't very", "Well that", "interact!'", "Press J to", "move around!", "'Use WASD to", "on controls.", "It's a book"],
    "10050": ["", "Good advice!", "answers.'", "online for", "searching", "stuck, try", "'If you get"],
    "10060": ["", "library?", "in a public", ":Why is this", "of the Land'", "Mysteries", "Secrets and", "'Forbidden"],
    "12231": ["", "sleeping!", "time to be", "This is no"],
};
var dialoguesStaged = [
    // Stage 0 - Bottle
    {
        "10133": ["", "already?", "you are here", "any hints if", "Do you need", "", "OrangeRKN", "Last post by", "", "------------", "grcade.co.uk", "", ":: *beep*"],   // Computer
        "00250": ["", ":mushrooms:", ":mmm:", ":Zzz:"], // Sleeping Mushroom Man
        "10222": ["", "the beach.", "Get back to", "doing here?!", "What are you"], // Madame
        "01252": ["", "is it?", "playthrough,", "your first", "this isn't", ":Huh? Oh,"], // Trendy Man
        "12132": ["", "recipe?", "What was the", "and: hmm?", "Eye of newt", "Caldron boil", "Double toil"],   // Witch
        "11352": ["", "can find!", "see what you", "- you should", "beach lately", "up on the", "been washing", "things have", "Lots of"],  // Croc
        "03443": ["", "night, ko ko!", "storm last", "Ook! Big"],   // Koko
        "00341": ["", "back?", "should go", "I guess I", "", "Grr:", "Yip! Yip!"],  // Fox
        "03023": ["", "here yet.", "can't go in", "Sorry, you"],    // Raccoon
        "01453": ["", "awake:", "are finally", "Hoot! You"],  // Owl
        "03454": ["", "came from.", "book this", "find the", "You should", "torn page!", "You got a", "the bottle:", "something in", "There's"],   // Bottle
        "00014": ["", "mushrooms?!", "mysterious", "not to pick", "never taught", "Were you"],  // Mushroom
    },
    // Stage 1 - Torn page
    {
        "10133": ["", "from there.", "is just up", "The library", "Keep going!", "", "Karl", "Last post by", "", "------------", "grcade.co.uk", "", ":: *beep*"],  // Computer
        "00250": ["", ":mushrooms:", ":mmm:", ":Zzz:"], // Sleeping Mushroom Man
        "10222": ["", "everywhere.", "her hair gets", "Bow! Even if", "darling Bow", "I love my"], // Madame
        "01252": ["", "of here.", "it's north", "the library,", "want to find", "me. If you", "don't mind", ":Huh? Oh,"], // Trendy Man
        "12132": ["", "recipe?", "What was the", "and: hmm?", "Eye of newt", "Caldron boil", "Double toil"],   // Witch
        "11352": ["", "later!", "see me again", "Come back to", "the cliffs.", "is just past", "Bema Village"],  // Croc
        "03443": ["", "koko miss?", "Ook? What"],   // Koko
        "00351": ["", "Yip!", "Yip! Yip!"],  // Fox
        "03023": ["", "here yet.", "can't go in", "Sorry, you"],  // Raccoon
        "01453": ["", "the dreamer.", "must awaken", "island, you", "to leave the", "If you wish", "Hoot! Hoot!"],  // Owl
        "00014": ["", "mushrooms?!", "mysterious", "not to pick", "never taught", "Were you"],  // Mushroom
        "10030": ["", "in this?", "interested", "Now who'd be", "recipe book!", "You got a", "missing:", "with a page", "book here", "There's a"],    // Bookcase goal
    },
    // Stage 2 - Recipe book
    {
        "01252": ["", "the forum!", "about it on", "here. I read", "secret back", "there is a", ":Huh? Oh,"],  // Trendy Man
        "12132": ["", "nice!", "something", "you'll get", "mushroom and", "Bring me a", ":hmm: :aha!", "that book!", "You, give me", "recipe?", "What was the", "and: hmm?", "Eye of newt", "Caldron boil", "Double toil"],   // Witch
        "11352": ["", "back later!", "I said come", "already?!", "Back again"], // Croc
        "01064": ["", "Be careful!", "the same.", "are rarely", "Two dreams", "I remember.", "is not as", "The island", "Hoot! Hoot!"], // Owl
        "00014": ["", "mushrooms?!", "mysterious", "not to pick", "never taught", "Were you"],  // Mushroom
    },
    // Stage 3 - Mushroom picking
    {
        "12132": ["", "nice!", "something", "you'll get", "mushroom and", "Bring me a"],   // Witch
    },
    // Stage 4 - Mushroom
    {
        "12132": ["", "yourself?", "drink it", ":Maybe don't", "potion!", "odd smelling", "You got an", "", ":", "", "special!", "up something", "I'll mix you", "the pot and", "Throw it in", "a mushroom!", "Ah, it has"],    // Witch
    },
    // Stage 5 - Potion
    {
        "12132": ["", "anyone!", "will perk up", "That potion"],    // Witch
    },
    // Stage 6 - Old broom
    {

    },
    // Stage X - Dreamer
    {
        "03444": ["", "to find me?", "Did you come", "one day.", "would return", "I knew you"],
    },
    { "03444": ["", "isn't it?", "to forget,", "It is hard", "This island:"] },
    { "03444": ["", "like it was.", "all to be", "I wanted it"] },
    { "03444": ["", "the sea.", "bottle into", "I threw that", "stop you.", "I tried to"] },
    { "03444": ["", "didn't you?", "all anyway,", "You fixed it"] },
    { "03444": ["", "point?", "what's the", "thing then", "change any-", "If you can't"] },
    { "03444": ["", "wake up now:", "I'm going to"] },
];

// Index in list defines which NPC, as commented
// Map Index, Map X Coord, Map Y Coord, Tile x, Tile y
var npcs = [
    [9, 0, 0, 0, 0],    // 0 Dreamer
    [9, 0, 0, 0, 0],    // 1 Mushroom Man
    [0, 0, 2, 5, 0],    // 2 Sleeping Mushroom Man
    [1, 0, 2, 2, 2],    // 3 Madame
    [1, 1, 2, 3, 3],    // 4 Bow Bow
    [0, 1, 2, 5, 2],    // 5 Trendy Man
    [1, 2, 0, 3, 2],    // 6 Mama
    [0, 4, 2, 4, 3],    // 7 Papa
    [1, 1, 1, 5, 2],    // 8 Shopkeeper
    [1, 2, 1, 3, 2],    // 9 Witch
    [1, 2, 1, 3, 3],    // 10 Caldron
    [1, 0, 3, 4, 2],    // 11 Grandma
    [1, 1, 3, 5, 2],    // 12 Croc
    [0, 3, 4, 4, 3],    // 13 Koko
    [9, 0, 0, 0, 0],    // 14 Ghost
    [0, 0, 3, 5, 1],    // 15 Fox
    [0, 3, 0, 2, 3],    // 16 Raccoon
    [0, 1, 4, 5, 3],    // 17 Owl
    [0, 0, 0, 1, 4],    // 18 Mushroom
    [9, 0, 0, 0, 0],    // 19 Signpost
    [0, 3, 4, 5, 4],    // 20 Bottle
];

// npcs gets updated every stage according to this list
var npcsDiffs = [
    // Stage 0 - Bottle
    {},
    // Stage 1 - Torn page
    {
        20: [9, 3, 4, 5, 4],    // Bottle
    },
    // Stage 2 - Recipe book
    {
        1: [0, 0, 1, 5, 1],     // Mushroom Man
        2: [9, 0, 0, 0, 0],     // Sleeping Mushroom Man
        4: [1, 1, 2, 5, 3],     // Bow Bow
        15: [0, 0, 3, 6, 1],    // Fox
        17: [0, 1, 0, 6, 4],    // Owl
    },
    // Stage 3 - Mushroom picking
    {
        1: [0, 0, 0, 3, 4],     // Mushroom Man
    },
    // Stage 4 - Mushroom
    {},
    // Stage 5 - Potion
    {},
    // Stage 6 - Old broom
    {},
    // Stage X - Dreamer
    {
        0: [0, 3, 4, 4, 4]      // Dreamer
    },
    {},
    {},
    {},
    {},
    {},
    {},
];

var stage = 0;
var goal = "03454";
var goals = ["", "03444", "03444", "03444", "03444", "03444", "03444", "00432", "10342", "12132", "00034", "12132", "10030"];

// Map Index, Map X Coord, Map Y Coord, Tile x, Tile y
var portals = {
    "01052": [1, 0, 0, 4, 4],
    "10045": [0, 1, 0, 5, 3],
    "02033": [1, 1, 0, 4, 4],
    "11045": [0, 2, 0, 3, 4],
    "02053": [1, 2, 0, 3, 4],
    "12035": [0, 2, 0, 5, 4],
    "01123": [1, 0, 1, 3, 4],
    "10135": [0, 1, 1, 2, 4],
    "03124": [1, 1, 1, 4, 4],
    "11145": [0, 3, 1, 2, 5],
    "03233": [1, 2, 1, 3, 4],
    "12135": [0, 3, 2, 3, 4],
    "01223": [1, 0, 2, 3, 4],
    "10235": [0, 1, 2, 2, 4],
    "01243": [1, 1, 2, 4, 4],
    "11245": [0, 1, 2, 4, 4],
    "02233": [1, 2, 2, 4, 4],
    "12245": [0, 2, 2, 3, 4],
    "01343": [1, 0, 3, 3, 4],
    "10335": [0, 1, 3, 4, 4],
    "01422": [1, 1, 3, 4, 4],
    "11345": [0, 1, 4, 2, 3],
    "04442": [1, 2, 3, 3, 4],
    "12335": [0, 4, 4, 4, 3],
    "01252": [1, 1, 2, 7, 0],
};

function resizeCanvas(increment) {
    scale = scale + increment;
    if (scale < 1) { scale = 1; }
    if (scale > 20) { scale = 20; }
    c.width = screenTileWidth * tsize * scale;
    c.height = screenTileHeight * tsize * scale;
    ctx.imageSmoothingEnabled = false;
    drawScreen();
}

function init() {
    ctx.imageSmoothingEnabled = false;
    mapXCoord = 2;
    mapYCoord = 4;
    updateLocale("24");
    playerPosX = 5 * tsize;
    playerPosY = 4 * tsize;
    dialogueBuffer = dialoguesDefault["init"].slice();
    dialogueFirstLine = dialogueBuffer.pop();
    dialogueSecondLine = dialogueBuffer.pop();

    update();
}

function update() {
    var start = Date.now();

    // Do stuff
    frameCount3 = frameCount3 + 1;
    if (frameCount3 > 3) {
        frameCount3 = 1;
    }
    processKeys();
    drawScreen();

    var delta = Date.now() - start;
    var delay = mspf - delta;
    // console.info(delay);
    if (delay > 0) {
        setTimeout(update, delay);
    } else {
        update();
    }
}

function updateLocale(coords) {
    for (i = 0; i < screenTileWidth; i++) {
        locale[i] = [];
        for (j = 0; j < screenTileHeight; j++) {
            locale[i][j] = map[coords].slice(j*screenTileWidth*2 + i*2, j*screenTileWidth*2 + i*2 + 2)
        }
    }

    localNPCs = [];
    localNPCDirections = [];
    for (i = 0; i < npcs.length; i++) {
        if (npcs[i][0] == mapIndex && npcs[i][1] == mapXCoord && npcs[i][2] == mapYCoord) {
            localNPCs.push(i);
            localNPCDirections.push(3);
        }
    }
}

function transitionScreen(xincrement, yincrement) {
    transitionXBuffer = 0;
    transitionYBuffer = 0;

    var coords = String(mapXCoord + xincrement) + String(mapYCoord + yincrement);
    if (coords in map) {
        mapXCoord = mapXCoord + xincrement;
        mapYCoord = mapYCoord + yincrement;
        updateLocale(coords);
    }

    // Press - at transition to screen warp
    if (!keyMap["-"]) {
        if (xincrement > 0) {
            playerPosX = minPosX + overscan;
        }
        if (xincrement < 0) {
            playerPosX = maxPosX - overscan;
        }
        if (yincrement > 0) {
            playerPosY = minPosY + overscan;
        }
        if (yincrement < 0) {
            playerPosY = maxPosY - overscan;
        }
    }

    inputDelayBuffer = transitionInputDelay;
}

function enterPortal() {
    var xCoord = Math.floor((playerPosX + (psize / 2)) / tsize);
    var yCoord = Math.floor((playerPosY + (psize - 1) * playerDirection[2]) / tsize);
    key = String(mapIndex) + String(mapXCoord) + String(mapYCoord) + String(xCoord) + String(yCoord);

    if (portals[key]) {
        portalBuffer = 0;
        transitionXBuffer = 0;
        transitionYBuffer = 0;

        mapIndex = portals[key][0]
        map = maps[mapIndex];
        mapXCoord = portals[key][1];
        mapYCoord = portals[key][2];
        playerPosX = portals[key][3] * tsize;
        playerPosY = portals[key][4] * tsize;
        tileset = tilesets[mapIndex];

        var coords = String(mapXCoord) + String(mapYCoord);
        updateLocale(coords);

        inputDelayBuffer = portalInputDelay;
    }
}

function drawScreen() {
    drawLocale();
    drawActors();
    drawDialogue();
}

function drawLocale() {
    for (i = 0; i < screenTileWidth; i++) {
        for (j = 0; j < screenTileHeight; j++) {
            var dx = i * tsize * scale;
            var dy = j * tsize * scale;
            var sx = parseInt(locale[i][j][0]) * tsize;
            var sy = parseInt(locale[i][j][1]) * tsize;
            ctx.drawImage(tileset, sx, sy, tsize, tsize, dx, dy, tsize * scale, tsize * scale);
        }
    }
}

function drawNPCs() {
    npcAnimationBuffer = npcAnimationBuffer + 1;
    if (npcAnimationBuffer == npcAnimationBufferMax) {
        npcAnimationFrame = Number(npcAnimationFrame == 0);
        npcAnimationBuffer = 0;
    }

    for (i = 0; i < localNPCs.length; i++) {
        var npc = npcs[localNPCs[i]];
        var sx = localNPCDirections[i] * tsize;
        var sy = ((localNPCs[i] * 2) + npcAnimationFrame) * tsize; // Test this with multiple NPCs
        ctx.drawImage(npcset, sx, sy, tsize, tsize, npc[3] * tsize * scale, npc[4] * tsize * scale, tsize * scale, tsize * scale);
    }
}

function drawPlayer() {
    if (playerMoving) {
        playerAnimationBuffer = playerAnimationBuffer + 1;
        if (playerAnimationBuffer == playerAnimationBufferMax) {
            playerAnimationFrame = Number(playerAnimationFrame == 0);
            playerAnimationBuffer = 0;
        }
    }

    var sx = 0;
    var sy = psize * playerAnimationFrame;
    if (playerDirection[0] == 1) {
        sx = 0;
    } else if (playerDirection[1] == 1) {
        sx = psize;
    } else if (playerDirection[2] == 1) {
        sx = psize * 2;
    } else if (playerDirection[3] == 1) {
        sx = psize * 3;
    }
    if (playerPushing) {
        sy = sy + (psize * 2);
    }
    if (playerDown) {
        sx = psize * 4;
        sy = psize * 3;
    }
    ctx.drawImage(player, sx, sy, psize, psize, playerPosX * scale, playerPosY * scale, psize * scale, psize * scale);

    // Surface overlay
    var feetXCoord = Math.floor((playerPosX + (psize / 2)) / tsize);
    var feetYCoord = Math.floor((playerPosY + (psize - 1)) / tsize);
    if (grassTiles[mapIndex].indexOf(locale[feetXCoord][feetYCoord]) >= 0) {
        sx = psize * 4;
        sy = 0;
        ctx.drawImage(player, sx, sy, psize, psize, playerPosX * scale, playerPosY * scale, psize * scale, psize * scale);
    }
}

function drawActors() {
    drawNPCs();
    drawPlayer();
}

function drawDialogue() {
    if (dialogueBuffer.length > 0) {
        // Blank text box
        for (i = 1; i < (screenTileWidth * 2) - 1; i++) {
            for (j = 1; j < 6; j++) {
                var dx = i * csize * scale;
                var dy = j * csize * scale;
                ctx.drawImage(charset, 0, 0, csize, csize, dx, dy, csize * scale, csize * scale);
            }
        }

        // First line
        for (i = 0; i < dialogueFirstLine.length; i++) {
            var dx = ((2 * csize) + (i * csize)) * scale;
            var dy = 2 * csize * scale;
            var sx = (characters.indexOf(dialogueFirstLine[i]) % 27) * csize;
            var sy = Math.floor(characters.indexOf(dialogueFirstLine[i]) / 27) * csize;
            ctx.drawImage(charset, sx, sy, csize, csize, dx, dy, csize * scale, csize * scale);
        }

        // Second line
        for (i = 0; i < dialogueSecondLine.length; i++) {
            var dx = ((2 * csize) + (i * csize)) * scale;
            var dy = 4 * csize * scale;
            var sx = (characters.indexOf(dialogueSecondLine[i]) % 27) * csize;
            var sy = Math.floor(characters.indexOf(dialogueSecondLine[i]) / 27) * csize;
            ctx.drawImage(charset, sx, sy, csize, csize, dx, dy, csize * scale, csize * scale);
        }

        // "Read more" prompt
        if (dialogueBuffer.length > 1) {
            var dx = ((screenTileWidth * 2) - 2) * csize * scale;
            var dy = 5 * csize * scale;
            ctx.drawImage(charset, 0, csize, csize, csize, dx, dy, csize * scale, csize * scale);
        }
    }
}

function playerStep(collinearAxis, reverse) {
    if (reverse) {
        inputDelayBuffer = reverseInputDelay;
        return;
    }

    playerMoving = true;
    playerPushing = false;

    if (collinearAxis == "x") {
        var collinearPos = playerPosX;
        var orthogonalPos = playerPosY;
        var minCollinearPos = minPosX;
        var maxCollinearPos = maxPosX;
        var minOrthogonalPos = minPosY;
        var maxOrthogonalPos = maxPosY;
        var positiveCollinearDirection = playerDirection[0];
        var negativeCollinearDirection = playerDirection[1];
        var collinearTransitionBuffer = transitionXBuffer;
        var screenTileMax = screenTileWidth;
        var orthogonalMovement = keyMap["w"] || keyMap["s"];
    } else if (collinearAxis == "y") {
        var collinearPos = playerPosY;
        var orthogonalPos = playerPosX;
        var minCollinearPos = minPosY;
        var maxCollinearPos = maxPosY;
        var minOrthogonalPos = minPosX;
        var maxOrthogonalPos = maxPosX;
        var positiveCollinearDirection = playerDirection[2];
        var negativeCollinearDirection = playerDirection[3];
        var collinearTransitionBuffer = transitionYBuffer;
        var screenTileMax = screenTileHeight;
        var orthogonalMovement = keyMap["a"] || keyMap["d"];
    } else {
        throw "Collinear axis must be 'x' or 'y'";
    }

    var newCollinearPos = collinearPos + positiveCollinearDirection - negativeCollinearDirection;
    var newOrthogonalPos = orthogonalPos;

    var collinearCoord = Math.floor((newCollinearPos + (psize - 1) * positiveCollinearDirection) / tsize);

    var start = Math.floor(orthogonalPos / tsize);
    var end = Math.floor((orthogonalPos + psize - 1) / tsize);
    var start1 = Math.floor((orthogonalPos + 1) / tsize);
    var end1 = Math.floor((orthogonalPos + psize - 2) / tsize);
    var start2 = Math.floor((orthogonalPos + 2) / tsize);
    var end2 = Math.floor((orthogonalPos + psize - 3) / tsize);

    // Overscan fix
    if (start < 0) {
        start = 0;
        start1 = 0;
        start2 = 0;
    } else if (start > screenTileMax + 1) {
        start = screenTileMax + 1;
        start1 = screenTileMax + 1;
        start2 = screenTileMax + 1;
    }
    if (end < 0) {
        end = 0;
        end1 = 0;
        end2 = 0;
    } else if (end > screenTileMax + 1) {
        end = screenTileMax + 1;
        end1 = screenTileMax + 1;
        end2 = screenTileMax + 1;
    }

    // Out of bounds is passable
    var startTile = "OOB";
    var endTile = "OOB";
    var start1Tile = "OOB";
    var end1Tile = "OOB";
    var start2Tile = "OOB";
    var end2Tile = "OOB";

    if ((collinearCoord >= 0) && (collinearCoord < screenTileMax)) {
        if (collinearAxis == "x") {
            startTile = locale[collinearCoord][start];
            endTile = locale[collinearCoord][end];
            start1Tile = locale[collinearCoord][start1];
            end1Tile = locale[collinearCoord][end1];
            start2Tile = locale[collinearCoord][start2];
            end2Tile = locale[collinearCoord][end2];
        } else if (collinearAxis == "y") {
            startTile = locale[start][collinearCoord];
            endTile = locale[end][collinearCoord];
            start1Tile = locale[start1][collinearCoord];
            end1Tile = locale[end1][collinearCoord];
            start2Tile = locale[start2][collinearCoord];
            end2Tile = locale[end2][collinearCoord];
        }
    }

    var passableStart = passableTiles[mapIndex].indexOf(startTile) >= 0;
    var passableEnd = passableTiles[mapIndex].indexOf(endTile) >= 0;
    if (!passableStart && !passableEnd) {
        newCollinearPos = collinearPos;
        playerPushing = true;
    } else if (passableStart && !passableEnd) {
        // Check for bump around corner
        if (passableTiles[mapIndex].indexOf(end1Tile) >= 0) {
            newOrthogonalPos = orthogonalPos - 1;
        } else if (passableTiles[mapIndex].indexOf(end2Tile) >= 0) {
            newOrthogonalPos = orthogonalPos - 1;
            newCollinearPos = collinearPos;
        } else {
            newCollinearPos = collinearPos;
            playerPushing = true;
        }
    } else if (!passableStart && passableEnd) {
        // Check for bump around corner
        if (passableTiles[mapIndex].indexOf(start1Tile) >= 0) {
            newOrthogonalPos = orthogonalPos + 1;
        } else if (passableTiles[mapIndex].indexOf(start2Tile) >= 0) {
            newOrthogonalPos = orthogonalPos + 1;
            newCollinearPos = collinearPos;
        } else {
            newCollinearPos = collinearPos;
            playerPushing = true;
        }
    }

    // Portals only in y direction
    if (collinearAxis == "y") {
        var portalStart = portalTiles[mapIndex].indexOf(startTile) >= 0;
        var portalEnd = portalTiles[mapIndex].indexOf(endTile) >= 0;
        if (portalStart && portalEnd) {
            portalBuffer = portalBuffer + 1;
            playerPushing = false;
        } else if (portalStart && !portalEnd) {
            if (portalTiles[mapIndex].indexOf(end2Tile) >= 0) {
                newOrthogonalPos = orthogonalPos - 1;
                portalBuffer = portalBuffer + 1;
                playerPushing = false;
            } else {
                portalBuffer = portalBuffer - 1;
            }
        } else if (!portalStart && portalEnd) {
            if (portalTiles[mapIndex].indexOf(start2Tile) >= 0) {
                newOrthogonalPos = orthogonalPos + 1;
                portalBuffer = portalBuffer + 1;
                playerPushing = false;
            } else {
                portalBuffer = portalBuffer - 1;
            }
        } else {
            portalBuffer = portalBuffer - 1;
        }
    } else if (!orthogonalMovement) {
        portalBuffer = portalBuffer - 1;
    }
    if (portalBuffer < 0) {
        portalBuffer = 0;
    }

    var npcStart = false;
    var npcEnd = false;
    var npcStart2 = false;
    var npcEnd2 = false;
    if (collinearAxis == "x") {
        var collinearIndex = 3;
        var orthogonalIndex = 4;
    } else if (collinearAxis == "y") {
        var collinearIndex = 4;
        var orthogonalIndex = 3;
    }
    for (i = 0; i < localNPCs.length; i++) {
        var npc = npcs[localNPCs[i]];
        if (npc[collinearIndex] == collinearCoord) {
            npcStart = npc[orthogonalIndex] == start;
            npcEnd = npc[orthogonalIndex] == end;
            npcStart2 = npc[orthogonalIndex] == start2;
            npcEnd2 = npc[orthogonalIndex] == end2;
        }
        if (npcStart && npcEnd) {
            newCollinearPos = collinearPos;
            playerMoving = false;
        } else if (!npcStart && npcEnd) {
            newCollinearPos = collinearPos;
            playerMoving = false;
            if (!npcEnd2) {
                newOrthogonalPos = orthogonalPos - 1;
            }
        } else if (npcStart && !npcEnd) {
            newCollinearPos = collinearPos;
            playerMoving = false;
            if (!npcStart2) {
                newOrthogonalPos = orthogonalPos + 1;
            }
        }
    }

    // Edge of screen
    var newCollinearTransitionBuffer = 0;
    if (newCollinearPos < minCollinearPos) {
        newCollinearPos = collinearPos;
        newCollinearTransitionBuffer = collinearTransitionBuffer - 1;
    } else if (newCollinearPos >= maxCollinearPos) {
        newCollinearPos = maxCollinearPos;
        newCollinearTransitionBuffer = collinearTransitionBuffer + 1;
    }

    // Always bump into screen if moving orthogonally to overscan
    if (orthogonalPos < (minOrthogonalPos + overscan)) {
        newOrthogonalPos = orthogonalPos + 1;
    } else if (orthogonalPos > (maxOrthogonalPos - overscan)) {
        newOrthogonalPos = orthogonalPos - 1;
    }

    if (orthogonalMovement) {
        // Fix to prevent corner bump with diagonal movement
        newOrthogonalPos = orthogonalPos;

        // Diagonal movement is always moving
        playerMoving = true;

        // Ignore every third frame of diagonal movement
        // Except when y movement is blocked
        if (collinearAxis == "x") {
            wasMovingX = newCollinearPos - collinearPos;;
        } else if (collinearAxis == "y") {
            wasMovingY = newCollinearPos - collinearPos;;
        }
        if (frameCount3 == 3) {
            newCollinearPos = collinearPos;
            newOrthogonalPos = orthogonalPos;

            if (collinearAxis == "x") {
                if (wasMovingX && !wasMovingY) {
                    newCollinearPos = collinearPos + wasMovingX;
                }
            }
        }
    }

    if (collinearAxis == "x") {
        playerPosX = newCollinearPos;
        playerPosY = newOrthogonalPos;
        transitionXBuffer = newCollinearTransitionBuffer;
    } else if (collinearAxis == "y") {
        playerPosY = newCollinearPos;
        playerPosX = newOrthogonalPos;
        transitionYBuffer = newCollinearTransitionBuffer;
    }
}

function interact() {
    var hpsize = psize / 2;
    var x = Math.floor((playerPosX + hpsize + (playerDirection[0] * hpsize) - (playerDirection[1] * hpsize) - playerDirection[1]) / tsize);
    var y = Math.floor((playerPosY + hpsize + (playerDirection[2] * hpsize) - (playerDirection[3] * hpsize) - playerDirection[3]) / tsize);
    var key = String(mapIndex) + String(mapXCoord) + String(mapYCoord) + String(x) + String(y);

    console.info(key);

    // Check for dialogue
    if (dialoguesStatic[key]) {
        dialogueBuffer = dialoguesStatic[key].slice();
    }

    if (dialoguesStaged[stage][key]) {
        dialogueBuffer = dialoguesStaged[stage][key].slice();
    }

    if ((0 <= x) && (x < screenTileWidth) && (0 <= y) && (y < screenTileHeight)) {
        if ((signpostTiles[mapIndex].indexOf(locale[x][y]) >= 0) && playerDirection[3] == 0) {
            dialogueBuffer = dialoguesDefault["signpost"].slice();
        }

        if (heavyTiles[mapIndex].indexOf(locale[x][y]) >= 0) {
            dialogueBuffer = dialoguesDefault["heavy"].slice();
        }

        if (drawerTiles[mapIndex].indexOf(locale[x][y]) >= 0) {
            dialogueBuffer = dialoguesDefault["drawer"].slice();
        }
    }

    // NPCs change direction to face player when interacted with
    for (i = 0; i < localNPCs.length; i++) {
        var npc = npcs[localNPCs[i]];
        if (npc[3] == x && npc[4] == y) {
            for (j = 0; j < playerDirection.length; j++) {
                if (playerDirection[j] == 1) {
                    localNPCDirections[i] = j;
                }
            }
        }
    }

    // Advance stage if goal reached
    if (goal == key) {
        stage = stage + 1;
        goal = goals.pop();
        Object.entries(npcsDiffs[stage]).forEach(
            ([key, value]) => npcs[key] = value
        );
    }
}

function processKeys() {
    var lastPlayerDirection = playerDirection;

    wasMovingX = 0;
    wasMovingY = 0;

    playerMoving = false;
    playerPushing = false;

    if (inputDelayBuffer > 0) {
        inputDelayBuffer = inputDelayBuffer - 1;
        return;
    }

    // Dialogue overrides other input
    if (dialogueBuffer.length > 0) {
        if (keyMap["j"]) {
            keyMap["j"] = false;
            dialogueFirstLine = dialogueSecondLine;
            dialogueSecondLine = dialogueBuffer.pop();
            inputDelayBuffer = dialogueInputDelay;
        }
        return;
    }

    playerDown = false;

    // Interact
    if (keyMap["j"]) {
        keyMap["j"] = false;
        interact();
        if (dialogueBuffer.length > 0) {
            dialogueFirstLine = dialogueBuffer.pop();
            dialogueSecondLine = dialogueBuffer.pop();
            inputDelayBuffer = dialogueInputDelay;
            return;
        }
    }

    // Movement
    if (keyMap["w"] && !keyMap["s"]) {
        playerDirection = [0,0,0,1];
        playerStep("y", lastPlayerDirection[2] == 1);
        if (transitionYBuffer < -transitionBufferMax) {
            transitionScreen(0, -1);
            return;
        }
        if (portalBuffer > portalBufferMax) {
            enterPortal();
            return;
        }
    }
    if (keyMap["s"] && !keyMap["w"]) {
        playerDirection = [0,0,1,0];
        playerStep("y", lastPlayerDirection[3] == 1);
        if (transitionYBuffer > transitionBufferMax) {
            transitionScreen(0, 1);
            return;
        }
        if (portalBuffer > portalBufferMax) {
            enterPortal();
            return;
        }
    }
    if (keyMap["a"] && !keyMap["d"] && portalBuffer < 3) {
        playerDirection = [0,1,0,0];
        playerStep("x", lastPlayerDirection[0] == 1);
        if (transitionXBuffer < -transitionBufferMax) {
            transitionScreen(-1, 0);
            return;
        }
    }
    if (keyMap["d"] && !keyMap["a"] && portalBuffer < 3) {
        playerDirection = [1,0,0,0];
        playerStep("x", lastPlayerDirection[1] == 1);
        if (transitionXBuffer > transitionBufferMax) {
            transitionScreen(1, 0);
            return;
        }
    }

    // Special cases
    // Kennel World
    if (keyMap["a"] && keyMap["s"]) {
        if (mapIndex == 0 && mapXCoord == 1 && mapYCoord == 2 && playerPosX == 60 && playerPosY == 24) {
            kennelBuffer = kennelBuffer + 1;
            if (kennelBuffer > portalBufferMax) {
                enterPortal();
                tileset = tilesets[0];
                return;
            }
        } else {
            kennelBuffer = 0;
        }
    } else {
        kennelBuffer = 0;
    }

    // Screen warp
    if ((transitionXBuffer == 0) && (transitionYBuffer == 0)) {
        keyMap["-"] = false;
    }
}

</script>

</body>
</html>
