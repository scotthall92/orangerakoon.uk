<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>sneek</title>
    <link rel="stylesheet" type="text/css" href="sneek.css">

    <!--
      ____                             _____       _
     / __ \                           |  __ \     | |
    | |  | |_ __ __ _ _ __   __ _  ___| |__) |__ _| | _____   ___  _ __
    | |  | | '__/ _` | '_ \ / _` |/ _ \  _  // _` | |/ / _ \ / _ \| '_ \
    | |__| | | | (_| | | | | (_| |  __/ | \ \ (_| |   < (_) | (_) | | | |
     \____/|_|  \__,_|_| |_|\__, |\___|_|  \_\__,_|_|\_\___/ \___/|_| |_|.uk
    =========================__/ |==========================================
                            |___/  Author: Scott Hall   github: scotthall92
    -->

</head>
<body>

<div class="center">
<noscript><h2>* This page requires JavaScript *</h2></noscript>
<p>Instructions go here</p>
</div>

<p class='attribution'><a href='/'><<< back to orangerakoon.uk</a></p>

<script type="text/javascript">

function cascadeRightReverse(i, actorLocations, newState) {
  var x = i;
  while (true) {
    x -= 1;
    if (actorLocations[x] == 'o') {
      // Player is caught so we can return out
      actorLocations[x] = 'x';
      return actorLocations;
    }
    if (actorLocations[x]) {
      // Keep cascading back with any right-moving guards reversed
      actorLocations[x] = 'z';
    } else if (newState[x] == '_') {
      // Return out as end of stack reached and reversed
      actorLocations[x] = 'z';
      return actorLocations;
    }
  }
}

function advanceState(action) {
  var state = location.hash.split('');
  var sanitisedHash = location.hash;
  sanitisedHash = sanitisedHash.replace(/o/g, '_').replace(/@/g, 'O');
  sanitisedHash = sanitisedHash.replace(/s/g, '_').replace(/z/g, '_');
  var newState = sanitisedHash.split('');
  var actorLocations = Array.apply(null, Array(state.length));

  // Check state validity
  if (!isValidState(state)) {
    location.hash = '##_INVALID_LEVEL_##'
    return;
  }

  // Game over
  if (state.indexOf('x') != -1) {
    location.hash = '#_x_GAME_OVER_x_#';
    return;
  }

  // Level complete
  if (state.indexOf('$') < 0) {
    location.hash = '#_-_LEVEL_COMPLETE_-_#';
    return;
  }

  // Iterate over state array
  for (i = 0; i < state.length; i++) {
    switch (state[i]) {

      case '@':  // Hidden player
        switch (action) {
          case 'interact':
          case 'wait':
            newState[i] = '@';
            break;
          case 'left':
            if (actorLocations[i-1]) {
              actorLocations[i-1] = 'x';
            } else {
              actorLocations[i-1] = 'o';
            }
            break;
          case 'right':
            if (actorLocations[i+1]) {
              actorLocations[i+1] = 'x';
            } else {
              actorLocations[i+1] = 'o';
            }
            break;
        }
        break;
      // case @ end

      case 'o':  // Player
        switch (action) {
          case 'interact':
            // To left
            if (state[i-1] == 'I') {
              newState[i-1] = 'H';
            } else if (state[i-1] == 'H') {
              newState[i-1] = 'I';
            }
            // To right
            if (state[i+1] == 'I') {
              newState[i+1] = 'H';
            } else if (state[i+1] == 'H') {
              newState[i+1] = 'I';
            }
            if (actorLocations[i]) {
              actorLocations[i] = 'x';
            } else {
              actorLocations[i] = 'o';
            }
            break;
          case 'wait':
            if (actorLocations[i]) {
              actorLocations[i] = 'x';
            } else {
              actorLocations[i] = 'o';
            }
            break;
          case 'left':
            // Movement blocked
            if (['#', 'I'].indexOf(state[i-1]) != -1) {
              if (actorLocations[i]) {
                actorLocations[i] = 'x';
              } else {
                actorLocations[i] = 'o';
              }
              break;
            }
            // Move through open door
            if (state[i-1] == 'H') {
              if (state[i-2] == 's') {
                actorLocations[i-2] = 'x';  // Prevent crossover
              } else if (actorLocations[i-2]) {
                actorLocations[i-2] = 'x';
              } else {
                actorLocations[i-2] = 'o';
              }
              break;
            }
            if (state[i-1] == 's') {
              actorLocations[i-1] = 'x';  // Prevent crossover
            } else if (actorLocations[i-1]) {
              actorLocations[i-1] = 'x';
            } else {
              actorLocations[i-1] = 'o';
            }
            break;
          case 'right':
            // Movement blocked
            if (['#', 'I'].indexOf(state[i+1]) != -1) {
              if (actorLocations[i]) {
                actorLocations[i] = 'x';
              } else {
                actorLocations[i] = 'o';
              }
              break;
            }
            // Move through open door
            if (state[i+1] == 'H') {
              if (state[i+2] == 'z') {
                actorLocations[i+2] = 'x';  // Prevent crossover
              } else if (actorLocations[i+2]) {
                actorLocations[i+2] = 'x';
              } else {
                actorLocations[i+2] = 'o';
              }
              break;
            }
            if (state[i+1] == 'z') {
              actorLocations[i+1] = 'x';  // Prevent crossover
            } else if (actorLocations[i+1]) {
              actorLocations[i+1] = 'x';
            } else {
              actorLocations[i+1] = 'o';
            }
            break;
        }
        break;
      // case o end

      case 's':  // Guard right-moving
        // Reverse direction
        if (['z','#','I'].indexOf(state[i+1]) != -1) {
          if (actorLocations[i] == 'o') {
            actorLocations[i] = 'x';
          } else if (actorLocations[i]) {
            actorLocations = cascadeRightReverse(i, actorLocations, newState);
          } else {
            actorLocations[i] = 'z';
          }
          break;
        }

        // Skip over right
        if (['H','O', '@', '$'].indexOf(state[i+1]) != -1) {
          // Reverse direction
          if (state[i+2] == 'z') {
            if (actorLocations[i] == 'o') {
              actorLocations[i] = 'x';
            } else if (actorLocations[i]) {
              actorLocations = cascadeRightReverse(i, actorLocations, newState);
            } else {
              actorLocations[i] = 'z';
            }
          } else {
            actorLocations[i+2] = 's';
          }
          break;
        }

        // Move right
        actorLocations[i+1] = 's';
        break;
      // case s end

      case 'z':  // Guard left-moving
        // Reverse direction
        if (['s','#','I'].indexOf(state[i-1]) != -1) {
          if (actorLocations[i] == 'o') {
            actorLocations[i] = 'x';
          } else {
            actorLocations[i] = 's';
          }
          break;
        }

        // Skip over left
        if (['H','O', '@', '$'].indexOf(state[i-1]) != -1) {
          // Reverse direction
          if (state[i-2] == 's') {
            if (actorLocations[i] == 'o') {
              actorLocations[i] = 'x';
            } else {
              actorLocations[i] = 's';
            }
          } else if (actorLocations[i-2] == 'o') {
            actorLocations[i-2] = 'x';
          } else if (actorLocations[i-2]) {
            // Reverse direction
            if (actorLocations[i] == 'o') {
              actorLocations[i] = 'x';
            } else {
              actorLocations[i] = 's';
            }
          } else {
            actorLocations[i-2] = 'z';
          }
          break;
        }

        // Move left
        if (actorLocations[i-1] == 'o') {
          actorLocations[i-1] = 'x';
        } else if (actorLocations[i-1]) {
          // Reverse direction
          if (actorLocations[i] == 'o') {
            actorLocations[i] = 'x';
          } else {
            actorLocations[i] = 's';
          }
        } else {
          actorLocations[i-1] = 'z';
        }
        break;
      // case z end
    }
  }

  // Add actorLocations to newState
  for (i = 0; i < newState.length; i++) {
    if (newState[i] == 'O') {
      if (actorLocations[i] == 'o') {
        newState[i] = '@';
      }
    } else {
      if (actorLocations[i]) {
        newState[i] = actorLocations[i];
      }
    }
  }

  location.hash = newState.join('');
}

function isValidState(state) {
  for (i = 0; i < state.length; i++) {
    // # I H O @ $ cannot appear next to each other
    if (['#', 'I', 'H', 'O', '@', '$'].indexOf(state[i]) != -1) {
      if (['#', 'I', 'H', 'O', '@', '$'].indexOf(state[i-1]) != -1) {
        return false;
      }
      if (['#', 'I', 'H', 'O', '@', '$'].indexOf(state[i+1]) != -1) {
        return false;
      }
    }
  }
  return true;
}

document.addEventListener("keypress", function onPress(event) {
  switch (event.key) {
    case "ArrowUp":
    case "w":
      advanceState('interact');
      break;
    case "ArrowDown":
    case "s":
      advanceState('wait');
      break;
    case "ArrowLeft":
    case "a":
      advanceState('left');
      break;
    case "ArrowRight":
    case "d":
      advanceState('right');
      break;
    default:
      return;
  }
});

</script>

</body>
</html>
